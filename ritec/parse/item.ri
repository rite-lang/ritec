import std:list
import std:result:Result

import ritec:ast
import ritec:span
import ritec:diagnostic
import ritec:diagnostic:Severity
import ritec:diagnostic:Diagnostic

import token:TokenStream
import token:Delimiter
import token:TokenTree
import token:Keyword
import token:Punct
import token:Doc

/// Parse a list of items
pub fn parse_items(
  stream: TokenStream
  acc:    [ast:Item]
) -> Result<[ast:Item] * TokenStream, Diagnostic>
  match token:peek(stream)
  | Eof, _ -> Ok((acc, stream))
  | _      ->
    let item, stream = item:parse(stream)?
    let acc = list:append(acc, item)
    parse_items(stream, acc)

/// Fn, Type, Import
/// decorators
/// Doc comments to fn, fn args (multiline) variants, variants fields multiline (as decorator)
pub fn parse(
  stream: TokenStream
) -> Result<ast:Item * TokenStream, Diagnostic>
  let stream = token:take_all(stream, Punct(Newline))
  let decorators, stream = parse_decorators(stream)?

  // allow a pub specifier before the item
  // disallow decorators for imports by requiring it to be empty.
  match (token:peek(stream), token:peek_nth(stream, 1), decorators)
  | (Keyword(Import), _), _                   , [] -> parse_import(stream)
  | (Keyword(Pub), _),    (Keyword(Import), _), [] -> parse_import(stream)
  | (Keyword(Type), _),   _                   , _  -> parse_type(stream, decorators)
  | (Keyword(Pub), _),    (Keyword(Type), _)  , _  -> parse_type(stream, decorators)
  | (Keyword(Fn), _),     _                   , _  -> parse_fn(stream, decorators)
  | (Keyword(Pub), _),    (Keyword(Fn), _)    , _  -> parse_fn(stream, decorators)
  | _ ->
    let token, span = token:peek(stream)
    diagnostic:new(
      severity: Error
      code:     "expected:item"
      message:  f"expected item, found `{token:format(token)}`"
    )
    |> diagnostic:add_label("here", span)
    |> Err

/// Parse all decorators (including doc comments) and newlines.
fn parse_decorators(
  stream: TokenStream
) -> Result<[ast:Decorator] * TokenStream, Diagnostic>
  parse_decorators_rec(stream, [])

fn parse_decorators_rec(
  stream: TokenStream
  acc:    [ast:Decorator]
) -> Result<[ast:Decorator] * TokenStream, Diagnostic>
  let token, span = token:peek(stream)

  match token
  | Doc(Item, comment) ->
    let stream = token:advance(stream, 1)
    let acc = list:append(acc, ast:Decorator(span, "doc", [comment]))
    parse_decorators_rec(stream, acc)
  | Punct(Pound) ->
    let decorator, stream = parse_decorator(stream)?
    let acc = list:append(acc, decorator)
    parse_decorators_rec(stream, acc)
  | Punct(Newline) -> parse_decorators_rec(token:advance(stream, 1), acc)
  | _ ->
    Ok((acc, stream))

/// Parse a single decorator
/// We parse the following pattern:
/// #
/// [ ... ] EOF
/// snake EOF?
/// ( ... ) EOF
/// str, ..., str EOF
fn parse_decorator(
  stream: TokenStream
) -> Result<ast:Decorator * TokenStream, Diagnostic>
  // we consume at least the first two tokens of the top
  // stream # [ ... ]
  let span, stream = token:expect(stream, Punct(Pound))?
  let token, group_span, stream = token:next(stream)
  let span = span:join(span, group_span)

  // a group is required.
  match token
  | Group(Brackets, group_stream) ->
    // the name is required as the first token of the group
    let name, _, group_stream = ritec:parse:parse_snake(group_stream)?
    // optionally parse args but if we are at the end
    // of the group, we are done
    let token, _, group_stream = token:next(group_stream)
    match token
    | Group(Parentheses, args_stream) ->
      let stream = token:advance(stream, 1)
      let args, args_stream = parse_decorator_args(args_stream, [])?

      token:expect(args_stream, Eof)?
      token:expect(group_stream, Eof)?

      Ok((ast:Decorator(span, name, args), stream))
    | _ ->
      token:expect(group_stream, Eof)?
      Ok((ast:Decorator(span, name, []), stream))

  | _ ->
    diagnostic:new(Error, "expected:brackets", f"expected brackets, found `{token:format(token)}`")
    |> diagnostic:add_label("here", span)
    |> Err

/// Collect string arguments for a decorator
fn parse_decorator_args(
  stream: TokenStream
  acc:    [str]
) -> Result<[str] * TokenStream, Diagnostic>
  let token, span, stream = token:next(stream)
  match token
  | String(s) ->
    let acc = list:append(acc, s)
    parse_decorator_args(stream, acc)
  | Punct(Comma) -> parse_decorator_args(stream, acc)
  | Eof -> Ok((acc, stream))
  | _ ->
    diagnostic:new(
      severity: Error
      code:     "expected:decorator_arg"
      message:  f"expected decorator argument, found `{token:format(token)}`"
    )
    |> diagnostic:add_label("here", span)
    |> Err

/// Parse all module doc comments (and newlines) as decorators.
pub fn parse_mod_doc_comments(
  stream: TokenStream
) -> Result<[ast:Decorator] * TokenStream, Diagnostic>
  parse_mod_doc_comments_rec(stream, [])

fn parse_mod_doc_comments_rec(
  stream: TokenStream
  acc:    [ast:Decorator]
) -> Result<[ast:Decorator] * TokenStream, Diagnostic>
  let token, span = token:peek(stream)
  match token
  | Doc(Module, comment) ->
    let stream = token:advance(stream, 1)
    let acc = list:append(acc, ast:Decorator(span, "moddoc", [comment]))
    parse_mod_doc_comments_rec(stream, acc)
  | Punct(Newline) -> parse_mod_doc_comments_rec(token:advance(stream, 1), acc)
  | _ -> Ok((acc, stream))

fn parse_import(
  stream: TokenStream
) -> Result<ast:Item * TokenStream, Diagnostic>
  let vis, stream = parse_vis(stream)?
  let span, stream = token:expect(stream, Keyword(Import))?
  let path, stream = ritec:parse:parse_path(stream)?
  Ok((ast:Item:Import(ast:Import:Import(span, vis, path)), stream))


fn parse_type(
  stream: TokenStream
  decorators: [ast:Decorator]
) -> Result<ast:Item * TokenStream, Diagnostic>
  let vis, stream = parse_vis(stream)?
  decorators |> std:debug:print
  panic

fn parse_fn(
  stream: TokenStream
  decorators: [ast:Decorator]
) -> Result<ast:Item * TokenStream, Diagnostic>
  let vis, stream = parse_vis(stream)?
  let span, stream = token:expect(stream, Keyword(Fn))?
  let name, name_span, stream = ritec:parse:parse_snake(stream)?
  let args, stream = parse_fn_args(stream)?
  let output, stream = parse_fn_output(stream)?
  let body, stream = parse_fn_body(stream)?

  Ok((ast:Item:Func(ast:Func:Func(span, decorators, vis, name, args, output, body)), stream))

/// Parse functions arguments, decide between
/// single line and multiline arguments.
fn parse_fn_args(
  stream: TokenStream
) -> Result<[ast:Argument] * TokenStream, Diagnostic>
  let token, span, stream = token:next(stream)

  match token
  | Group(Parentheses, group_stream) ->
    // parse ( ... )
    let token, span = token:peek(group_stream)

    match token
    | Punct(Newline) ->
      // parse:
      // (
      //   arg: ty(,)?
      //   ...
      //   arg: ty(,)?
      // )
      let group_stream = token:advance(group_stream, 1)
      match token:next(group_stream)
      | Group(Indent, indent_stream), _, group_stream ->
        let args, indent_stream = parse_fn_args_multiline(indent_stream, [])?
        token:expect(group_stream, Eof)?
        Ok((args, stream))
      | _ ->
        diagnostic:new(Error, "expected:indent", f"expected indent, found `{token:format(token)}`")
        |> diagnostic:add_label("here", span)
        |> Err
    // parse: arg: ty, ..., arg: ty
    | _ ->
      let args, group_stream = parse_fn_args_line(group_stream, [])?
      token:expect(group_stream, Eof)?
      Ok((args, stream))

  | _ ->
    diagnostic:new(Error, "expected:parentheses", f"expected parentheses, found `{token:format(token)}`")
    |> diagnostic:add_label("here", span)
    |> Err

/// Parse a single function line seperated by commas
fn parse_fn_args_line(
  stream: TokenStream
  acc:    [ast:Argument]
) -> Result<[ast:Argument] * TokenStream, Diagnostic>
  let token, span = token:peek(stream)
  match token
  | Punct(Comma) -> parse_fn_args_line(token:advance(stream, 1), acc)
  | Eof -> Ok((acc, stream))
  | Snake(_) ->
    let arg, stream = parse_fn_arg(stream, [])?
    let acc = list:append(acc, arg)
    parse_fn_args_line(stream, acc)
  | _ ->
    diagnostic:new(Error, "expected:snake", f"expected snake, found `{token:format(token)}`")
    |> diagnostic:add_label("here", span)
    |> Err

/// Parse a multiline function arguments seperated by newlines
/// commas are optional.
fn parse_fn_args_multiline(
  stream: TokenStream
  acc:    [ast:Argument]
) -> Result<[ast:Argument] * TokenStream, Diagnostic>
  // takes all comments, decorators and newlines
  let decorators, stream = parse_decorators(stream)?
  let arg, stream = parse_fn_arg(stream, decorators)?
  let acc = list:append(acc, arg)
  let _, stream = token:take(stream, Punct(Comma))
  let token, span = token:peek(stream)
  match token
  | Punct(Newline) -> parse_fn_args_multiline(token:advance(stream, 1), acc)
  | Eof -> Ok((acc, stream))
  | _ ->
    diagnostic:new(Error, "expected:newline", f"expected newline, found `{token:format(token)}`")
    |> diagnostic:add_label("here", span)
    |> Err

fn parse_fn_arg(
  stream: TokenStream
  decorators: [ast:Decorator]
) -> Result<ast:Argument * TokenStream, Diagnostic>
  let name, name_span, stream = ritec:parse:parse_snake(stream)?

  let ty, stream = match token:peek(stream)
    | Punct(Colon), _ ->
      let _, stream = token:expect(stream, Punct(Colon))?
      let ty, stream = ritec:parse:ty:parse(stream)?
      Ok(ty), stream
    | _ -> Err(void), stream

  Ok((ast:Argument(name_span, decorators, name, ty), stream))

/// Parse an optional function output type
/// -> Ty
fn parse_fn_output(
  stream: TokenStream
) -> Result<Result<ast:Ty, void> * TokenStream, Diagnostic>
  match token:take(stream, Punct(Arrow))
  | Ok(_), stream ->
    let ty, stream = ritec:parse:ty:parse(stream)?
    Ok((Ok(ty), stream))
  | Err(_), stream -> Ok((Err(void), stream))

/// Parse an optional function body (only multiline)
fn parse_fn_body(
  stream: TokenStream
) -> Result<Result<ast:Expr, void> * TokenStream, Diagnostic>
  let stream = token:take_all(stream, Punct(Newline))

  match token:peek(stream)
  | Group(Indent, group_stream), _ ->
    let expr, stream = ritec:parse:expr:parse_block(stream)?
    Ok((Ok(expr), stream))
  | _ -> Ok((Err(void), stream))

/// Parse a visibility modifier, defaults to private.
fn parse_vis(
  stream: TokenStream
) -> Result<ast:Vis * TokenStream, Diagnostic>
  match token:take(stream, Keyword(Pub))
  | Ok((_, span)), stream -> Ok((ast:Vis:Public, stream))
  | Err(_), stream -> Ok((ast:Vis:Private, stream))